# comette-plugin

Rust bindings for a comette plugin.

See a bunch of examples in [`comette-plugins`](https://github.com/blorbb/comette-plugins). [Protobuf definitions](https://protobuf.dev/) are in [`proto/plugin.proto`](./proto/plugin.proto), if you want to make bindings for another language.

## Usage

Example implementation below. For more details, see the crate's documentation.

Add `comette-plugin` to `Cargo.toml`. You may also need `tokio` and `serde`.

```rs
use comette_plugin::{Plugin, Result, ListItem, ActivationContext, Action, Input};
use serde::Deserialize;

fn main() {
    // This will run the server
    comette_plugin::main::<MyPlugin>()
}

// If you need any data from the configuration, add
// `serde` and `toml` to dependencies.
// Otherwise, a unit struct `struct MyPlugin;` will work.
#[derive(Deserialize)]
struct MyPlugin {
    some_data: Vec<String>,
}

impl Plugin for MyPlugin {
    // runs once when the program is started.
    // `config` is a string in TOML format of this plugin's config.
    async fn new(config: String) -> Result<Self> {
        let some_data = toml::from_str(&config)?;
        Ok(Self { some_data })
    }

    // runs for every change to the query, if the prefix matches
    // this plugin
    async fn query(&self, query: String) -> Result<List> {
        let list_items: Vec<ListItem> = /* ... */;
        // ...
        Ok(List::new(list_items))
    }

    // runs when the user clicks / presses enter on a selected list item.
    // the list item will always have been generated by this plugin.
    async fn activate(
        &self,
        ActivationContext { item, .. }: ActivationContext
    ) -> Result<Vec<Action>> {
        // ...
        // Return a vec of actions to perform. These will be run in order.
        Ok(vec![
            Action::Close, // You will usually want to close the app.
            Action::RunShell(item.metadata),
        ])
    }

    // runs when the user runs an autocomplete command (tab by default)
    // on a list item. you should modify the input line by returning
    // a new input (or None if the input should not be modified)
    async fn complete(
        &self,
        ActivationContext { item, query, .. }: ActivationContext
    ) -> Result<Option<Input>> {
        // ...
        Ok(Some(Input::new("new input")))
    }
}
```

`comette-plugin` also gives access to an sqlite pool at `comette_plugin::sql::pool()`. This is a connection to the plugin's sqlite database. By default, it stores a `activations` table that updates on every activation.

The `activations` table has the following schema:

```sql
CREATE TABLE activations (
    id          INTEGER PRIMARY KEY,
    title       TEXT NOT NULL UNIQUE,
    frequency   INTEGER NOT NULL,
    last_use    DATETIME NOT NULL
);
```

The plugin can store any other tables it wants here.

## Bindings for other languages

Currently, only Rust bindings exist. Bindings for other languages may be made in the future.

The program needs to run a server with RPC services that follow the protobuf definition.

-   When initialising, it needs to connect to a port in loopback (`[::1]`) and print the port to stdout (e.g. `12345`).
    -   The comette backend will then connect to `http://[::1]:<port>`.
-   If an error occurs during initialisation, you should exit with a non-zero exit code.
-   The backend is guaranteed to call and complete the initialise function before any other functions are called.
